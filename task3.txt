
Если для элементов вектора можно определить порядок, то сначала можно отсортировать элементы, а потом за один проход скопировать уникальные в новый вектор за O(n). Сложность зависит от выбранного алгоритма сортировки. Например, если выберем сортировку слияниями, то сложность по времени будет O(n*log(n)) + O(n) = O(n*log(n)).  Сложность по памяти - O(n) дополнительной памяти для сортировки  и O(n) для отбирания уникальных.

Если элементы нельзя отсортировать, но для них можно придумать  хэш-функцию, то можно использовать какой-нибудь hashset, например std::unordered_set. Сложность создания hashset в среднем O(n), в худшем случае O(n^2). Сложность по памяти hashset = O(n). Алгоритм такой - заполняем hashset всеми элементами исходного вектора, затем читаем их из него в новый вектор.

Если и хэш функцию придумать нельзя, то сравнивать элементы  друг с другом - сначала первый копируем в новый вектор. Затем каждый оставшийся элемент из исходного вектора сравниваем со скопированными и копируем, если ещё не скопировали, и т.д... Сложность по времени O(n^2), дополнительная память не требуется, кроме нового вектора.
